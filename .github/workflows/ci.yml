name: prac-pipe

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start containers for test
        run: docker compose up -d

      - name: Test app health
        run: docker compose exec -T app curl -f http://localhost:3000/health

      - name: Stop test containers
        run: docker compose down -v

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build Docker images
        run: docker-compose build

      - name: Tag Docker images
        run: |
          docker tag app ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:app-latest
          docker tag web ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:web-latest
          docker tag db ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:db-latest

      - name: Push Docker images
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:app-latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:web-latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:db-latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH key
        env:
          PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "$PRIVATE_KEY" > private_key
          chmod 600 private_key

      - name: Deploy on EC2
        env:
          HOSTNAME: ${{ secrets.EC2_HOST }}
          USERNAME: ${{ secrets.EC2_USER }}
        run: |
          ssh -o StrictHostKeyChecking=no -i private_key ${USERNAME}@${HOSTNAME} << 'EOF'

          # Create .env file on EC2 with secrets from GitHub
          cat > ~/myapp/.env << EOL
          DB_USER=${{ secrets.DB_USER }}
          DB_PASS=${{ secrets.DB_PASS }}
          DB_NAME=${{ secrets.DB_NAME }}
          ROOT_PASS=${{ secrets.ROOT_PASS }}
          EOL

          # Create docker-compose.yml that uses images instead of build
          cat > ~/myapp/docker-compose.yml << 'YAML'
          version: '3'
          services:
            app:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:app-latest
              environment:
                - DB_HOST=db
                - DB_USER=${DB_USER}
                - DB_PASSWORD=${DB_PASS}
                - DB_NAME=${DB_NAME}
              ports:
                - "3000:3000"
              depends_on:
                - db

             web:
               image: ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:web-latest
               ports:
                 - "8080:80"
               depends_on:
                 - app

             db:
               image: ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:db-latest
               environment:
                 - MYSQL_ROOT_PASSWORD=${ROOT_PASS}
                 - MYSQL_USER=${DB_USER}
                 - MYSQL_PASSWORD=${DB_PASS}
                 - MYSQL_DATABASE=${DB_NAME}
               volumes:
                 - db-data:/var/lib/mysql

          volumes:
            db-data:
          YAML

          # Pull latest images
          docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:app-latest
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:web-latest
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/my-3tier-app:db-latest

          # Run containers
          docker-compose -f ~/myapp/docker-compose.yml up -d
          EOF
